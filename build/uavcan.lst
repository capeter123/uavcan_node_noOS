ARM GAS  /tmp/ccxbGVnb.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"uavcan.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.shouldAcceptTransfer,"ax",%progbits
  16              		.align	1
  17              		.global	shouldAcceptTransfer
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	shouldAcceptTransfer:
  24              	.LFB65:
  25              		.file 1 "Src/uavcan.c"
   1:Src/uavcan.c  **** #include "canard.h"
   2:Src/uavcan.c  **** #include "canard_stm32.h"
   3:Src/uavcan.c  **** #include "uavcan.h"
   4:Src/uavcan.c  **** #include "stm32f1xx_hal.h"
   5:Src/uavcan.c  **** 
   6:Src/uavcan.c  **** #define CANARD_SPIN_PERIOD   500
   7:Src/uavcan.c  **** #define PUBLISHER_PERIOD_mS     25
   8:Src/uavcan.c  ****             
   9:Src/uavcan.c  **** static CanardInstance g_canard;                //The library instance
  10:Src/uavcan.c  **** static uint8_t g_canard_memory_pool[1024];     //Arena for memory allocation, used by the library
  11:Src/uavcan.c  **** static uint32_t  g_uptime = 0;
  12:Src/uavcan.c  **** 
  13:Src/uavcan.c  **** 
  14:Src/uavcan.c  **** 
  15:Src/uavcan.c  ****  void sendCanard(void);
  16:Src/uavcan.c  ****  void receiveCanard(void);
  17:Src/uavcan.c  ****  void spinCanard(void);
  18:Src/uavcan.c  ****  void publishCanard(void);
  19:Src/uavcan.c  ****  void rawcmdHandleCanard(CanardRxTransfer* transfer);
  20:Src/uavcan.c  ****  void getsetHandleCanard(CanardRxTransfer* transfer);
  21:Src/uavcan.c  ****  void getNodeInfoHandleCanard(CanardRxTransfer* transfer);
  22:Src/uavcan.c  ****  //uint16_t encodeParamCanard(param_t * p, uint8_t * buffer);
  23:Src/uavcan.c  ****  uint16_t makeNodeInfoMessage(uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE]);
  24:Src/uavcan.c  **** 
  25:Src/uavcan.c  **** //////////////////////////////////////////////////////////////////////////////////////
  26:Src/uavcan.c  **** 
  27:Src/uavcan.c  **** bool shouldAcceptTransfer(const CanardInstance* ins,
  28:Src/uavcan.c  ****                           uint64_t* out_data_type_signature,
  29:Src/uavcan.c  ****                           uint16_t data_type_id,
  30:Src/uavcan.c  ****                           CanardTransferType transfer_type,
  31:Src/uavcan.c  ****                           uint8_t source_node_id)
  32:Src/uavcan.c  **** {
  26              		.loc 1 32 0
ARM GAS  /tmp/ccxbGVnb.s 			page 2


  27              		.cfi_startproc
  28              		@ args = 4, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
  33:Src/uavcan.c  ****     if ((transfer_type == CanardTransferTypeRequest) &&(data_type_id == UAVCAN_GET_NODE_INFO_DATA_T
  32              		.loc 1 33 0
  33 0000 012B     		cmp	r3, #1
  34 0002 01D0     		beq	.L5
  34:Src/uavcan.c  ****     {
  35:Src/uavcan.c  ****         *out_data_type_signature = UAVCAN_GET_NODE_INFO_DATA_TYPE_SIGNATURE;
  36:Src/uavcan.c  ****         return true;
  37:Src/uavcan.c  ****     }
  38:Src/uavcan.c  ****     return false;
  35              		.loc 1 38 0
  36 0004 0020     		movs	r0, #0
  37              	.LVL1:
  38 0006 7047     		bx	lr
  39              	.LVL2:
  40              	.L5:
  33:Src/uavcan.c  ****     if ((transfer_type == CanardTransferTypeRequest) &&(data_type_id == UAVCAN_GET_NODE_INFO_DATA_T
  41              		.loc 1 33 0 discriminator 1
  42 0008 012A     		cmp	r2, #1
  43 000a 01D0     		beq	.L6
  44              		.loc 1 38 0
  45 000c 0020     		movs	r0, #0
  46              	.LVL3:
  39:Src/uavcan.c  **** }
  47              		.loc 1 39 0
  48 000e 7047     		bx	lr
  49              	.LVL4:
  50              	.L6:
  35:Src/uavcan.c  ****         return true;
  51              		.loc 1 35 0
  52 0010 03A3     		adr	r3, .L7
  53 0012 D3E90023 		ldrd	r2, [r3]
  54              	.LVL5:
  55 0016 C1E90023 		strd	r2, [r1]
  36:Src/uavcan.c  ****     }
  56              		.loc 1 36 0
  57 001a 0120     		movs	r0, #1
  58              	.LVL6:
  59 001c 7047     		bx	lr
  60              	.L8:
  61 001e 00BF     		.align	3
  62              	.L7:
  63 0020 9E6AC421 		.word	566520478
  64 0024 818A46EE 		.word	-297366911
  65              		.cfi_endproc
  66              	.LFE65:
  68              		.section	.text.uavcanInit,"ax",%progbits
  69              		.align	1
  70              		.global	uavcanInit
  71              		.syntax unified
  72              		.thumb
  73              		.thumb_func
  74              		.fpu softvfp
ARM GAS  /tmp/ccxbGVnb.s 			page 3


  76              	uavcanInit:
  77              	.LFB68:
  40:Src/uavcan.c  **** 
  41:Src/uavcan.c  **** //////////////////////////////////////////////////////////////////////////////////////
  42:Src/uavcan.c  **** 
  43:Src/uavcan.c  **** void onTransferReceived(CanardInstance* ins, CanardRxTransfer* transfer)
  44:Src/uavcan.c  **** {
  45:Src/uavcan.c  ****     if ((transfer->transfer_type == CanardTransferTypeRequest) &&
  46:Src/uavcan.c  ****         (transfer->data_type_id == UAVCAN_GET_NODE_INFO_DATA_TYPE_ID))
  47:Src/uavcan.c  ****     {
  48:Src/uavcan.c  ****         getNodeInfoHandleCanard(transfer);
  49:Src/uavcan.c  ****     } 
  50:Src/uavcan.c  ****     
  51:Src/uavcan.c  **** }
  52:Src/uavcan.c  **** 
  53:Src/uavcan.c  **** void getNodeInfoHandleCanard(CanardRxTransfer* transfer)
  54:Src/uavcan.c  **** {
  55:Src/uavcan.c  ****         uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE];
  56:Src/uavcan.c  ****         memset(buffer,0,UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
  57:Src/uavcan.c  ****         uint16_t len = makeNodeInfoMessage(buffer);
  58:Src/uavcan.c  ****         int result = canardRequestOrRespond(&g_canard,
  59:Src/uavcan.c  ****                                             transfer->source_node_id,
  60:Src/uavcan.c  ****                                             UAVCAN_GET_NODE_INFO_DATA_TYPE_SIGNATURE,
  61:Src/uavcan.c  ****                                             UAVCAN_GET_NODE_INFO_DATA_TYPE_ID,
  62:Src/uavcan.c  ****                                             &transfer->transfer_id,
  63:Src/uavcan.c  ****                                             transfer->priority,
  64:Src/uavcan.c  ****                                             CanardResponse,
  65:Src/uavcan.c  ****                                             &buffer[0],
  66:Src/uavcan.c  ****                                             (uint16_t)len);
  67:Src/uavcan.c  **** }
  68:Src/uavcan.c  **** 
  69:Src/uavcan.c  **** 
  70:Src/uavcan.c  **** 
  71:Src/uavcan.c  **** 
  72:Src/uavcan.c  **** 
  73:Src/uavcan.c  **** void uavcanInit(void)
  74:Src/uavcan.c  **** {
  78              		.loc 1 74 0
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 8
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  83              	.LCFI0:
  84              		.cfi_def_cfa_offset 20
  85              		.cfi_offset 4, -20
  86              		.cfi_offset 5, -16
  87              		.cfi_offset 6, -12
  88              		.cfi_offset 7, -8
  89              		.cfi_offset 14, -4
  90 0002 85B0     		sub	sp, sp, #20
  91              	.LCFI1:
  92              		.cfi_def_cfa_offset 40
  75:Src/uavcan.c  ****     CanardSTM32CANTimings timings;
  76:Src/uavcan.c  ****     int result = canardSTM32ComputeCANTimings(HAL_RCC_GetPCLK1Freq(), 1000000, &timings);
  93              		.loc 1 76 0
  94 0004 FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
  95              	.LVL7:
ARM GAS  /tmp/ccxbGVnb.s 			page 4


  96              	.LBB5:
  97              	.LBB6:
  98              		.file 2 "libcanard/drivers/stm32/canard_stm32.h"
   1:libcanard/drivers/stm32/canard_stm32.h **** /*
   2:libcanard/drivers/stm32/canard_stm32.h ****  * Copyright (c) 2017 UAVCAN Team
   3:libcanard/drivers/stm32/canard_stm32.h ****  *
   4:libcanard/drivers/stm32/canard_stm32.h ****  * Distributed under the MIT License, available in the file LICENSE.
   5:libcanard/drivers/stm32/canard_stm32.h ****  *
   6:libcanard/drivers/stm32/canard_stm32.h ****  * Author: Pavel Kirienko <pavel.kirienko@zubax.com>
   7:libcanard/drivers/stm32/canard_stm32.h ****  */
   8:libcanard/drivers/stm32/canard_stm32.h **** 
   9:libcanard/drivers/stm32/canard_stm32.h **** #ifndef CANARD_STM32_H
  10:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_H
  11:libcanard/drivers/stm32/canard_stm32.h **** 
  12:libcanard/drivers/stm32/canard_stm32.h **** #include <canard.h>
  13:libcanard/drivers/stm32/canard_stm32.h **** #include <string.h>     // NOLINT
  14:libcanard/drivers/stm32/canard_stm32.h **** 
  15:libcanard/drivers/stm32/canard_stm32.h **** 
  16:libcanard/drivers/stm32/canard_stm32.h **** #ifdef __cplusplus
  17:libcanard/drivers/stm32/canard_stm32.h **** extern "C"
  18:libcanard/drivers/stm32/canard_stm32.h **** {
  19:libcanard/drivers/stm32/canard_stm32.h **** #endif
  20:libcanard/drivers/stm32/canard_stm32.h **** 
  21:libcanard/drivers/stm32/canard_stm32.h **** /**
  22:libcanard/drivers/stm32/canard_stm32.h ****  * Set this build config macro to 1 to use CAN2 instead of CAN1, if available.
  23:libcanard/drivers/stm32/canard_stm32.h ****  * Setting this parameter when CAN2 is not available may not be detected at compile time!
  24:libcanard/drivers/stm32/canard_stm32.h ****  */
  25:libcanard/drivers/stm32/canard_stm32.h **** #if !defined(CANARD_STM32_USE_CAN2)
  26:libcanard/drivers/stm32/canard_stm32.h **** # define CANARD_STM32_USE_CAN2                                  0
  27:libcanard/drivers/stm32/canard_stm32.h **** #endif
  28:libcanard/drivers/stm32/canard_stm32.h **** 
  29:libcanard/drivers/stm32/canard_stm32.h **** /**
  30:libcanard/drivers/stm32/canard_stm32.h ****  * Trigger an assertion failure if inner priority inversion is detected at run time.
  31:libcanard/drivers/stm32/canard_stm32.h ****  * This setting has no effect in release builds, where NDEBUG is defined.
  32:libcanard/drivers/stm32/canard_stm32.h ****  */
  33:libcanard/drivers/stm32/canard_stm32.h **** #if !defined(CANARD_STM32_DEBUG_INNER_PRIORITY_INVERSION)
  34:libcanard/drivers/stm32/canard_stm32.h **** # define CANARD_STM32_DEBUG_INNER_PRIORITY_INVERSION            1
  35:libcanard/drivers/stm32/canard_stm32.h **** #endif
  36:libcanard/drivers/stm32/canard_stm32.h **** 
  37:libcanard/drivers/stm32/canard_stm32.h **** /**
  38:libcanard/drivers/stm32/canard_stm32.h ****  * Driver error codes.
  39:libcanard/drivers/stm32/canard_stm32.h ****  * These values are returned negated from API functions that return int.
  40:libcanard/drivers/stm32/canard_stm32.h ****  */
  41:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE                         1000
  42:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_MSR_INAK_NOT_SET                             1001
  43:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_MSR_INAK_NOT_CLEARED                         1002
  44:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_UNSUPPORTED_FRAME_FORMAT                     1003
  45:libcanard/drivers/stm32/canard_stm32.h **** 
  46:libcanard/drivers/stm32/canard_stm32.h **** /**
  47:libcanard/drivers/stm32/canard_stm32.h ****  * This is defined by the bxCAN hardware.
  48:libcanard/drivers/stm32/canard_stm32.h ****  * Devices with only one CAN interface have 14 filters (e.g. F103).
  49:libcanard/drivers/stm32/canard_stm32.h ****  * Devices with two CAN interfaces have 28 filters, which are shared between two interfaces (e.g. F
  50:libcanard/drivers/stm32/canard_stm32.h ****  * The filters are distributed between CAN1 and CAN2 by means of the CAN2 start filter bank selecti
  51:libcanard/drivers/stm32/canard_stm32.h ****  * which is a number from 1 to 27 inclusive. Seeing as the start bank cannot be set to 0, CAN2 has 
  52:libcanard/drivers/stm32/canard_stm32.h ****  * to use.
  53:libcanard/drivers/stm32/canard_stm32.h ****  */
  54:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_NUM_ACCEPTANCE_FILTERS                            14U
ARM GAS  /tmp/ccxbGVnb.s 			page 5


  55:libcanard/drivers/stm32/canard_stm32.h **** 
  56:libcanard/drivers/stm32/canard_stm32.h **** /**
  57:libcanard/drivers/stm32/canard_stm32.h ****  * The interface can be initialized in either of these modes.
  58:libcanard/drivers/stm32/canard_stm32.h ****  *
  59:libcanard/drivers/stm32/canard_stm32.h ****  * The Silent mode is useful for automatic CAN bit rate detection, where the interface is initializ
  60:libcanard/drivers/stm32/canard_stm32.h ****  * arbitrarily guessed CAN bit rate (typically either 1 Mbps, 500 Kbps, 250 Kbps, or 125 Kbps, thes
  61:libcanard/drivers/stm32/canard_stm32.h ****  * standard values defined by the UAVCAN specification), and the bus is then listened for 1 second 
  62:libcanard/drivers/stm32/canard_stm32.h ****  * determine whether the bit rate was guessed correctly. It is paramount to use the silent mode in 
  63:libcanard/drivers/stm32/canard_stm32.h ****  * as to not interfere with ongoing communications on the bus if the guess was incorrect.
  64:libcanard/drivers/stm32/canard_stm32.h ****  *
  65:libcanard/drivers/stm32/canard_stm32.h ****  * The automatic TX abort on error mode should be used during dynamic node ID allocation. The reaso
  66:libcanard/drivers/stm32/canard_stm32.h ****  * is well explained in the UAVCAN specification, please read it.
  67:libcanard/drivers/stm32/canard_stm32.h ****  *
  68:libcanard/drivers/stm32/canard_stm32.h ****  * The normal mode should be used for all other use cases, particularly for the normal operation of
  69:libcanard/drivers/stm32/canard_stm32.h ****  * hence the name.
  70:libcanard/drivers/stm32/canard_stm32.h ****  */
  71:libcanard/drivers/stm32/canard_stm32.h **** typedef enum
  72:libcanard/drivers/stm32/canard_stm32.h **** {
  73:libcanard/drivers/stm32/canard_stm32.h ****     CanardSTM32IfaceModeNormal,                         //!< Normal mode
  74:libcanard/drivers/stm32/canard_stm32.h ****     CanardSTM32IfaceModeSilent,                         //!< Do not affect the bus, only listen
  75:libcanard/drivers/stm32/canard_stm32.h ****     CanardSTM32IfaceModeAutomaticTxAbortOnError         //!< Abort pending TX if a bus error has oc
  76:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32IfaceMode;
  77:libcanard/drivers/stm32/canard_stm32.h **** 
  78:libcanard/drivers/stm32/canard_stm32.h **** /**
  79:libcanard/drivers/stm32/canard_stm32.h ****  * Interface statistics; these values can be queried using a dedicated API call.
  80:libcanard/drivers/stm32/canard_stm32.h ****  */
  81:libcanard/drivers/stm32/canard_stm32.h **** typedef struct
  82:libcanard/drivers/stm32/canard_stm32.h **** {
  83:libcanard/drivers/stm32/canard_stm32.h ****     uint64_t rx_overflow_count;
  84:libcanard/drivers/stm32/canard_stm32.h ****     uint64_t error_count;
  85:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32Stats;
  86:libcanard/drivers/stm32/canard_stm32.h **** 
  87:libcanard/drivers/stm32/canard_stm32.h **** /**
  88:libcanard/drivers/stm32/canard_stm32.h ****  * ID and Mask of a hardware acceptance filter.
  89:libcanard/drivers/stm32/canard_stm32.h ****  * The ID and Mask fields support flags @ref CANARD_CAN_FRAME_EFF and @ref CANARD_CAN_FRAME_RTR.
  90:libcanard/drivers/stm32/canard_stm32.h ****  */
  91:libcanard/drivers/stm32/canard_stm32.h **** typedef struct
  92:libcanard/drivers/stm32/canard_stm32.h **** {
  93:libcanard/drivers/stm32/canard_stm32.h ****     uint32_t id;
  94:libcanard/drivers/stm32/canard_stm32.h ****     uint32_t mask;
  95:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32AcceptanceFilterConfiguration;
  96:libcanard/drivers/stm32/canard_stm32.h **** 
  97:libcanard/drivers/stm32/canard_stm32.h **** /**
  98:libcanard/drivers/stm32/canard_stm32.h ****  * These parameters define the timings of the CAN controller.
  99:libcanard/drivers/stm32/canard_stm32.h ****  * Please refer to the documentation of the bxCAN macrocell for explanation.
 100:libcanard/drivers/stm32/canard_stm32.h ****  * These values can be computed by the developed beforehand if ROM size is of a concern,
 101:libcanard/drivers/stm32/canard_stm32.h ****  * or they can be computed at run time using the function defined below.
 102:libcanard/drivers/stm32/canard_stm32.h ****  */
 103:libcanard/drivers/stm32/canard_stm32.h **** typedef struct
 104:libcanard/drivers/stm32/canard_stm32.h **** {
 105:libcanard/drivers/stm32/canard_stm32.h ****     uint16_t bit_rate_prescaler;                        /// [1, 1024]
 106:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bit_segment_1;                              /// [1, 16]
 107:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bit_segment_2;                              /// [1, 8]
 108:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t max_resynchronization_jump_width;           /// [1, 4] (recommended value is 1)
 109:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32CANTimings;
 110:libcanard/drivers/stm32/canard_stm32.h **** 
 111:libcanard/drivers/stm32/canard_stm32.h **** /**
ARM GAS  /tmp/ccxbGVnb.s 			page 6


 112:libcanard/drivers/stm32/canard_stm32.h ****  * Initializes the CAN controller at the specified bit rate.
 113:libcanard/drivers/stm32/canard_stm32.h ****  * The mode can be either normal, silent, or auto-abort on error;
 114:libcanard/drivers/stm32/canard_stm32.h ****  * in silent mode the controller will be only listening, not affecting the state of the bus;
 115:libcanard/drivers/stm32/canard_stm32.h ****  * in the auto abort mode the controller will cancel the pending transmissions if a bus error is en
 116:libcanard/drivers/stm32/canard_stm32.h ****  * The auto abort mode is needed for dynamic node ID allocation procedure; please refer to the UAVC
 117:libcanard/drivers/stm32/canard_stm32.h ****  * for more information about this topic.
 118:libcanard/drivers/stm32/canard_stm32.h ****  *
 119:libcanard/drivers/stm32/canard_stm32.h ****  * This function can be invoked any number of times; every invocation re-initializes everything fro
 120:libcanard/drivers/stm32/canard_stm32.h ****  *
 121:libcanard/drivers/stm32/canard_stm32.h ****  * WARNING: The clock of the CAN module must be enabled before this function is invoked!
 122:libcanard/drivers/stm32/canard_stm32.h ****  *          If CAN2 is used, CAN1 must be also enabled!
 123:libcanard/drivers/stm32/canard_stm32.h ****  *
 124:libcanard/drivers/stm32/canard_stm32.h ****  * WARNING: The driver is not thread-safe!
 125:libcanard/drivers/stm32/canard_stm32.h ****  *          It does not use IRQ or critical sections though, so it is safe to invoke its API functi
 126:libcanard/drivers/stm32/canard_stm32.h ****  *          IRQ context from the application.
 127:libcanard/drivers/stm32/canard_stm32.h ****  *
 128:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               Success
 129:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 130:libcanard/drivers/stm32/canard_stm32.h ****  */
 131:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32Init(const CanardSTM32CANTimings* const timings,
 132:libcanard/drivers/stm32/canard_stm32.h ****                         const CanardSTM32IfaceMode iface_mode);
 133:libcanard/drivers/stm32/canard_stm32.h **** 
 134:libcanard/drivers/stm32/canard_stm32.h **** /**
 135:libcanard/drivers/stm32/canard_stm32.h ****  * Pushes one frame into the TX buffer, if there is space.
 136:libcanard/drivers/stm32/canard_stm32.h ****  * Note that proper care is taken to ensure that no inner priority inversion is taking place.
 137:libcanard/drivers/stm32/canard_stm32.h ****  * This function does never block.
 138:libcanard/drivers/stm32/canard_stm32.h ****  *
 139:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      1               Transmitted successfully
 140:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               No space in the buffer
 141:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 142:libcanard/drivers/stm32/canard_stm32.h ****  */
 143:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32Transmit(const CanardCANFrame* const frame);
 144:libcanard/drivers/stm32/canard_stm32.h **** 
 145:libcanard/drivers/stm32/canard_stm32.h **** /**
 146:libcanard/drivers/stm32/canard_stm32.h ****  * Reads one frame from the hardware RX FIFO, unless all FIFO are empty.
 147:libcanard/drivers/stm32/canard_stm32.h ****  * This function does never block.
 148:libcanard/drivers/stm32/canard_stm32.h ****  *
 149:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      1               Read successfully
 150:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               The buffer is empty
 151:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 152:libcanard/drivers/stm32/canard_stm32.h ****  */
 153:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32Receive(CanardCANFrame* const out_frame);
 154:libcanard/drivers/stm32/canard_stm32.h **** 
 155:libcanard/drivers/stm32/canard_stm32.h **** /**
 156:libcanard/drivers/stm32/canard_stm32.h ****  * Sets up acceptance filters according to the provided list of ID and masks.
 157:libcanard/drivers/stm32/canard_stm32.h ****  * Note that when the interface is reinitialized, hardware acceptance filters are reset.
 158:libcanard/drivers/stm32/canard_stm32.h ****  * Also note that during filter reconfiguration, some RX frames may be lost.
 159:libcanard/drivers/stm32/canard_stm32.h ****  *
 160:libcanard/drivers/stm32/canard_stm32.h ****  * Setting zero filters will result in rejection of all frames.
 161:libcanard/drivers/stm32/canard_stm32.h ****  * In order to accept all frames, set one filter with ID = Mask = 0, which is also the default conf
 162:libcanard/drivers/stm32/canard_stm32.h ****  *
 163:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               Success
 164:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 165:libcanard/drivers/stm32/canard_stm32.h ****  */
 166:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32ConfigureAcceptanceFilters(const CanardSTM32AcceptanceFilterConfiguration* const
 167:libcanard/drivers/stm32/canard_stm32.h ****                                               const uint8_t num_filter_configs);
 168:libcanard/drivers/stm32/canard_stm32.h **** 
ARM GAS  /tmp/ccxbGVnb.s 			page 7


 169:libcanard/drivers/stm32/canard_stm32.h **** /**
 170:libcanard/drivers/stm32/canard_stm32.h ****  * Returns the running interface statistics.
 171:libcanard/drivers/stm32/canard_stm32.h ****  */
 172:libcanard/drivers/stm32/canard_stm32.h **** CanardSTM32Stats canardSTM32GetStats(void);
 173:libcanard/drivers/stm32/canard_stm32.h **** 
 174:libcanard/drivers/stm32/canard_stm32.h **** /**
 175:libcanard/drivers/stm32/canard_stm32.h ****  * Given the rate of the clock supplied to the bxCAN macrocell (typically PCLK1) and the desired bi
 176:libcanard/drivers/stm32/canard_stm32.h ****  * this function iteratively solves for the best possible timing settings. The CAN bus timing param
 177:libcanard/drivers/stm32/canard_stm32.h ****  * such as the sample point location, the number of time quantas per bit, etc., are optimized accor
 178:libcanard/drivers/stm32/canard_stm32.h ****  * recommendations provided in the specifications of UAVCAN, DeviceNet, and CANOpen.
 179:libcanard/drivers/stm32/canard_stm32.h ****  *
 180:libcanard/drivers/stm32/canard_stm32.h ****  * Unless noted otherwise, all units are SI units; particularly, frequency is specified in hertz.
 181:libcanard/drivers/stm32/canard_stm32.h ****  *
 182:libcanard/drivers/stm32/canard_stm32.h ****  * The implementation is adapted from libuavcan.
 183:libcanard/drivers/stm32/canard_stm32.h ****  *
 184:libcanard/drivers/stm32/canard_stm32.h ****  * This function is defined in the header in order to encourage the linker to discard it if it is n
 185:libcanard/drivers/stm32/canard_stm32.h ****  *
 186:libcanard/drivers/stm32/canard_stm32.h ****  * @retval 0            Success
 187:libcanard/drivers/stm32/canard_stm32.h ****  * @retval negative     Solution could not be found for the provided inputs.
 188:libcanard/drivers/stm32/canard_stm32.h ****  */
 189:libcanard/drivers/stm32/canard_stm32.h **** static inline
 190:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32ComputeCANTimings(const uint32_t peripheral_clock_rate,
 191:libcanard/drivers/stm32/canard_stm32.h ****                                      const uint32_t target_bitrate,
 192:libcanard/drivers/stm32/canard_stm32.h ****                                      CanardSTM32CANTimings* const out_timings)
 193:libcanard/drivers/stm32/canard_stm32.h **** {
 194:libcanard/drivers/stm32/canard_stm32.h ****     if (target_bitrate < 1000)
 195:libcanard/drivers/stm32/canard_stm32.h ****     {
 196:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;
 197:libcanard/drivers/stm32/canard_stm32.h ****     }
 198:libcanard/drivers/stm32/canard_stm32.h **** 
 199:libcanard/drivers/stm32/canard_stm32.h ****     CANARD_ASSERT(out_timings != NULL);  // NOLINT
 200:libcanard/drivers/stm32/canard_stm32.h ****     memset(out_timings, 0, sizeof(*out_timings));
  99              		.loc 2 200 0
 100 0008 0023     		movs	r3, #0
 101 000a 0293     		str	r3, [sp, #8]
 102 000c ADF80C30 		strh	r3, [sp, #12]	@ movhi
 103              	.LVL8:
 201:libcanard/drivers/stm32/canard_stm32.h **** 
 202:libcanard/drivers/stm32/canard_stm32.h ****     /*
 203:libcanard/drivers/stm32/canard_stm32.h ****      * Hardware configuration
 204:libcanard/drivers/stm32/canard_stm32.h ****      */
 205:libcanard/drivers/stm32/canard_stm32.h ****     static const uint8_t MaxBS1 = 16;
 206:libcanard/drivers/stm32/canard_stm32.h ****     static const uint8_t MaxBS2 = 8;
 207:libcanard/drivers/stm32/canard_stm32.h **** 
 208:libcanard/drivers/stm32/canard_stm32.h ****     /*
 209:libcanard/drivers/stm32/canard_stm32.h ****      * Ref. "Automatic Baudrate Detection in CANopen Networks", U. Koppe, MicroControl GmbH & Co. K
 210:libcanard/drivers/stm32/canard_stm32.h ****      *      CAN in Automation, 2003
 211:libcanard/drivers/stm32/canard_stm32.h ****      *
 212:libcanard/drivers/stm32/canard_stm32.h ****      * According to the source, optimal quanta per bit are:
 213:libcanard/drivers/stm32/canard_stm32.h ****      *   Bitrate        Optimal Maximum
 214:libcanard/drivers/stm32/canard_stm32.h ****      *   1000 kbps      8       10
 215:libcanard/drivers/stm32/canard_stm32.h ****      *   500  kbps      16      17
 216:libcanard/drivers/stm32/canard_stm32.h ****      *   250  kbps      16      17
 217:libcanard/drivers/stm32/canard_stm32.h ****      *   125  kbps      16      17
 218:libcanard/drivers/stm32/canard_stm32.h ****      */
 219:libcanard/drivers/stm32/canard_stm32.h ****     const uint8_t max_quanta_per_bit = (uint8_t)((target_bitrate >= 1000000) ? 10 : 17);    // NOLI
 220:libcanard/drivers/stm32/canard_stm32.h ****     CANARD_ASSERT(max_quanta_per_bit <= (MaxBS1 + MaxBS2));
ARM GAS  /tmp/ccxbGVnb.s 			page 8


 221:libcanard/drivers/stm32/canard_stm32.h **** 
 222:libcanard/drivers/stm32/canard_stm32.h ****     static const uint16_t MaxSamplePointLocationPermill = 900;
 223:libcanard/drivers/stm32/canard_stm32.h **** 
 224:libcanard/drivers/stm32/canard_stm32.h ****     /*
 225:libcanard/drivers/stm32/canard_stm32.h ****      * Computing (prescaler * BS):
 226:libcanard/drivers/stm32/canard_stm32.h ****      *   BITRATE = 1 / (PRESCALER * (1 / PCLK) * (1 + BS1 + BS2))       -- See the Reference Manual
 227:libcanard/drivers/stm32/canard_stm32.h ****      *   BITRATE = PCLK / (PRESCALER * (1 + BS1 + BS2))                 -- Simplified
 228:libcanard/drivers/stm32/canard_stm32.h ****      * let:
 229:libcanard/drivers/stm32/canard_stm32.h ****      *   BS = 1 + BS1 + BS2                                             -- Number of time quanta pe
 230:libcanard/drivers/stm32/canard_stm32.h ****      *   PRESCALER_BS = PRESCALER * BS
 231:libcanard/drivers/stm32/canard_stm32.h ****      * ==>
 232:libcanard/drivers/stm32/canard_stm32.h ****      *   PRESCALER_BS = PCLK / BITRATE
 233:libcanard/drivers/stm32/canard_stm32.h ****      */
 234:libcanard/drivers/stm32/canard_stm32.h ****     const uint32_t prescaler_bs = peripheral_clock_rate / target_bitrate;
 104              		.loc 2 234 0
 105 0010 424C     		ldr	r4, .L32
 106 0012 A4FB0034 		umull	r3, r4, r4, r0
 107 0016 A40C     		lsrs	r4, r4, #18
 108              	.LVL9:
 235:libcanard/drivers/stm32/canard_stm32.h **** 
 236:libcanard/drivers/stm32/canard_stm32.h ****     /*
 237:libcanard/drivers/stm32/canard_stm32.h ****      * Searching for such prescaler value so that the number of quanta per bit is highest.
 238:libcanard/drivers/stm32/canard_stm32.h ****      */
 239:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs1_bs2_sum = (uint8_t)(max_quanta_per_bit - 1);    // NOLINT
 109              		.loc 2 239 0
 110 0018 0923     		movs	r3, #9
 111              	.LVL10:
 112              	.L10:
 240:libcanard/drivers/stm32/canard_stm32.h **** 
 241:libcanard/drivers/stm32/canard_stm32.h ****     while ((prescaler_bs % (1U + bs1_bs2_sum)) != 0)
 113              		.loc 2 241 0
 114 001a 591C     		adds	r1, r3, #1
 115 001c B4FBF1F2 		udiv	r2, r4, r1
 116 0020 01FB1242 		mls	r2, r1, r2, r4
 117 0024 22B1     		cbz	r2, .L28
 242:libcanard/drivers/stm32/canard_stm32.h ****     {
 243:libcanard/drivers/stm32/canard_stm32.h ****         if (bs1_bs2_sum <= 2)
 118              		.loc 2 243 0
 119 0026 022B     		cmp	r3, #2
 120 0028 73D9     		bls	.L22
 244:libcanard/drivers/stm32/canard_stm32.h ****         {
 245:libcanard/drivers/stm32/canard_stm32.h ****             return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;          // No solution
 246:libcanard/drivers/stm32/canard_stm32.h ****         }
 247:libcanard/drivers/stm32/canard_stm32.h ****         bs1_bs2_sum--;
 121              		.loc 2 247 0
 122 002a 013B     		subs	r3, r3, #1
 123              	.LVL11:
 124 002c DBB2     		uxtb	r3, r3
 125              	.LVL12:
 126 002e F4E7     		b	.L10
 127              	.L28:
 248:libcanard/drivers/stm32/canard_stm32.h ****     }
 249:libcanard/drivers/stm32/canard_stm32.h **** 
 250:libcanard/drivers/stm32/canard_stm32.h ****     const uint32_t prescaler = prescaler_bs / (1U + bs1_bs2_sum);
 128              		.loc 2 250 0
 129 0030 B4FBF1F1 		udiv	r1, r4, r1
 130              	.LVL13:
ARM GAS  /tmp/ccxbGVnb.s 			page 9


 251:libcanard/drivers/stm32/canard_stm32.h ****     if ((prescaler < 1U) || (prescaler > 1024U))
 131              		.loc 2 251 0
 132 0034 4A1E     		subs	r2, r1, #1
 133 0036 B2F5806F 		cmp	r2, #1024
 134 003a 6CD2     		bcs	.L23
 252:libcanard/drivers/stm32/canard_stm32.h ****     {
 253:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;              // No solution
 254:libcanard/drivers/stm32/canard_stm32.h ****     }
 255:libcanard/drivers/stm32/canard_stm32.h **** 
 256:libcanard/drivers/stm32/canard_stm32.h ****     /*
 257:libcanard/drivers/stm32/canard_stm32.h ****      * Now we have a constraint: (BS1 + BS2) == bs1_bs2_sum.
 258:libcanard/drivers/stm32/canard_stm32.h ****      * We need to find such values so that the sample point is as close as possible to the optimal 
 259:libcanard/drivers/stm32/canard_stm32.h ****      * which is 87.5%, which is 7/8.
 260:libcanard/drivers/stm32/canard_stm32.h ****      *
 261:libcanard/drivers/stm32/canard_stm32.h ****      *   Solve[(1 + bs1)/(1 + bs1 + bs2) == 7/8, bs2]  (* Where 7/8 is 0.875, the recommended sampl
 262:libcanard/drivers/stm32/canard_stm32.h ****      *   {{bs2 -> (1 + bs1)/7}}
 263:libcanard/drivers/stm32/canard_stm32.h ****      *
 264:libcanard/drivers/stm32/canard_stm32.h ****      * Hence:
 265:libcanard/drivers/stm32/canard_stm32.h ****      *   bs2 = (1 + bs1) / 7
 266:libcanard/drivers/stm32/canard_stm32.h ****      *   bs1 = (7 * bs1_bs2_sum - 1) / 8
 267:libcanard/drivers/stm32/canard_stm32.h ****      *
 268:libcanard/drivers/stm32/canard_stm32.h ****      * Sample point location can be computed as follows:
 269:libcanard/drivers/stm32/canard_stm32.h ****      *   Sample point location = (1 + bs1) / (1 + bs1 + bs2)
 270:libcanard/drivers/stm32/canard_stm32.h ****      *
 271:libcanard/drivers/stm32/canard_stm32.h ****      * Since the optimal solution is so close to the maximum, we prepare two solutions, and then pi
 272:libcanard/drivers/stm32/canard_stm32.h ****      *   - With rounding to nearest
 273:libcanard/drivers/stm32/canard_stm32.h ****      *   - With rounding to zero
 274:libcanard/drivers/stm32/canard_stm32.h ****      */
 275:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs1 = (uint8_t)(((7 * bs1_bs2_sum - 1) + 4) / 8);       // Trying rounding to nearest f
 135              		.loc 2 275 0
 136 003c C3EBC306 		rsb	r6, r3, r3, lsl #3
 137 0040 F21C     		adds	r2, r6, #3
 138 0042 22D4     		bmi	.L29
 139              	.L13:
 140 0044 D210     		asrs	r2, r2, #3
 141 0046 D5B2     		uxtb	r5, r2
 142              	.LVL14:
 276:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs2 = (uint8_t)(bs1_bs2_sum - bs1);  // NOLINT
 143              		.loc 2 276 0
 144 0048 5F1B     		subs	r7, r3, r5
 145 004a FFB2     		uxtb	r7, r7
 146              	.LVL15:
 277:libcanard/drivers/stm32/canard_stm32.h ****     CANARD_ASSERT(bs1_bs2_sum > bs1);
 147              		.loc 2 277 0
 148 004c AB42     		cmp	r3, r5
 149 004e 1ED9     		bls	.L30
 150              	.LBB7:
 278:libcanard/drivers/stm32/canard_stm32.h **** 
 279:libcanard/drivers/stm32/canard_stm32.h ****     {
 280:libcanard/drivers/stm32/canard_stm32.h ****         const uint16_t sample_point_permill = (uint16_t)(1000U * (1U + bs1) / (1U + bs1 + bs2));  /
 151              		.loc 2 280 0
 152 0050 D2B2     		uxtb	r2, r2
 153 0052 4FF47A74 		mov	r4, #1000
 154              	.LVL16:
 155 0056 02FB0444 		mla	r4, r2, r4, r4
 156 005a 3A44     		add	r2, r2, r7
 157 005c 0132     		adds	r2, r2, #1
ARM GAS  /tmp/ccxbGVnb.s 			page 10


 158 005e B4FBF2F2 		udiv	r2, r4, r2
 159 0062 92B2     		uxth	r2, r2
 160              	.LVL17:
 281:libcanard/drivers/stm32/canard_stm32.h **** 
 282:libcanard/drivers/stm32/canard_stm32.h ****         if (sample_point_permill > MaxSamplePointLocationPermill)   // Strictly more!
 161              		.loc 2 282 0
 162 0064 B2F5617F 		cmp	r2, #900
 163 0068 05D9     		bls	.L15
 283:libcanard/drivers/stm32/canard_stm32.h ****         {
 284:libcanard/drivers/stm32/canard_stm32.h ****             bs1 = (uint8_t)((7 * bs1_bs2_sum - 1) / 8);             // Nope, too far; now rounding 
 164              		.loc 2 284 0
 165 006a 751E     		subs	r5, r6, #1
 166              	.LVL18:
 167 006c 16D4     		bmi	.L31
 168              	.L16:
 169 006e C5F3C705 		ubfx	r5, r5, #3, #8
 170              	.LVL19:
 285:libcanard/drivers/stm32/canard_stm32.h ****             bs2 = (uint8_t)(bs1_bs2_sum - bs1);
 171              		.loc 2 285 0
 172 0072 5B1B     		subs	r3, r3, r5
 173              	.LVL20:
 174 0074 DFB2     		uxtb	r7, r3
 175              	.LVL21:
 176              	.L15:
 177              	.LBE7:
 286:libcanard/drivers/stm32/canard_stm32.h ****         }
 287:libcanard/drivers/stm32/canard_stm32.h ****     }
 288:libcanard/drivers/stm32/canard_stm32.h **** 
 289:libcanard/drivers/stm32/canard_stm32.h ****     const bool valid = (bs1 >= 1) && (bs1 <= MaxBS1) && (bs2 >= 1) && (bs2 <= MaxBS2);
 178              		.loc 2 289 0
 179 0076 6B1E     		subs	r3, r5, #1
 180 0078 DBB2     		uxtb	r3, r3
 181 007a 0F2B     		cmp	r3, #15
 182 007c 10D8     		bhi	.L24
 183 007e 002F     		cmp	r7, #0
 184 0080 3CD0     		beq	.L25
 185 0082 082F     		cmp	r7, #8
 186 0084 3CD9     		bls	.L26
 187 0086 0022     		movs	r2, #0
 188              	.LVL22:
 189 0088 0BE0     		b	.L17
 190              	.LVL23:
 191              	.L29:
 275:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs2 = (uint8_t)(bs1_bs2_sum - bs1);  // NOLINT
 192              		.loc 2 275 0
 193 008a 0732     		adds	r2, r2, #7
 194 008c DAE7     		b	.L13
 195              	.LVL24:
 196              	.L30:
 277:libcanard/drivers/stm32/canard_stm32.h **** 
 197              		.loc 2 277 0
 198 008e 244B     		ldr	r3, .L32+4
 199              	.LVL25:
 200 0090 244A     		ldr	r2, .L32+8
 201 0092 40F21511 		movw	r1, #277
 202              	.LVL26:
 203 0096 2448     		ldr	r0, .L32+12
ARM GAS  /tmp/ccxbGVnb.s 			page 11


 204              	.LVL27:
 205 0098 FFF7FEFF 		bl	__assert_func
 206              	.LVL28:
 207              	.L31:
 208              	.LBB8:
 284:libcanard/drivers/stm32/canard_stm32.h ****             bs2 = (uint8_t)(bs1_bs2_sum - bs1);
 209              		.loc 2 284 0
 210 009c 0735     		adds	r5, r5, #7
 211 009e E6E7     		b	.L16
 212              	.LVL29:
 213              	.L24:
 214              	.LBE8:
 215              		.loc 2 289 0
 216 00a0 0022     		movs	r2, #0
 217              	.LVL30:
 218              	.L17:
 290:libcanard/drivers/stm32/canard_stm32.h **** 
 291:libcanard/drivers/stm32/canard_stm32.h ****     /*
 292:libcanard/drivers/stm32/canard_stm32.h ****      * Final validation
 293:libcanard/drivers/stm32/canard_stm32.h ****      * Helpful Python:
 294:libcanard/drivers/stm32/canard_stm32.h ****      * def sample_point_from_btr(x):
 295:libcanard/drivers/stm32/canard_stm32.h ****      *     assert 0b0011110010000000111111000000000 & x == 0
 296:libcanard/drivers/stm32/canard_stm32.h ****      *     ts2,ts1,brp = (x>>20)&7, (x>>16)&15, x&511
 297:libcanard/drivers/stm32/canard_stm32.h ****      *     return (1+ts1+1)/(1+ts1+1+ts2+1)
 298:libcanard/drivers/stm32/canard_stm32.h ****      */
 299:libcanard/drivers/stm32/canard_stm32.h ****     if ((target_bitrate != (peripheral_clock_rate / (prescaler * (1U + bs1 + bs2)))) ||
 219              		.loc 2 299 0
 220 00a2 EB19     		adds	r3, r5, r7
 221 00a4 03FB0113 		mla	r3, r3, r1, r1
 222 00a8 B0FBF3F0 		udiv	r0, r0, r3
 223              	.LVL31:
 224 00ac 1F4B     		ldr	r3, .L32+16
 225 00ae 9842     		cmp	r0, r3
 226 00b0 28D1     		bne	.L18
 227 00b2 3AB3     		cbz	r2, .L18
 300:libcanard/drivers/stm32/canard_stm32.h ****         !valid)
 301:libcanard/drivers/stm32/canard_stm32.h ****     {
 302:libcanard/drivers/stm32/canard_stm32.h ****         // This actually means that the algorithm has a logic error, hence assert(0).
 303:libcanard/drivers/stm32/canard_stm32.h ****         CANARD_ASSERT(0);  // NOLINT
 304:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;
 305:libcanard/drivers/stm32/canard_stm32.h ****     }
 306:libcanard/drivers/stm32/canard_stm32.h **** 
 307:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->bit_rate_prescaler = (uint16_t) prescaler;
 228              		.loc 2 307 0
 229 00b4 ADF80810 		strh	r1, [sp, #8]	@ movhi
 308:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->max_resynchronization_jump_width = 1;      // One is recommended by UAVCAN, CANOpe
 230              		.loc 2 308 0
 231 00b8 0123     		movs	r3, #1
 232 00ba 8DF80C30 		strb	r3, [sp, #12]
 309:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->bit_segment_1 = bs1;
 233              		.loc 2 309 0
 234 00be 8DF80A50 		strb	r5, [sp, #10]
 310:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->bit_segment_2 = bs2;
 235              		.loc 2 310 0
 236 00c2 8DF80B70 		strb	r7, [sp, #11]
 311:libcanard/drivers/stm32/canard_stm32.h **** 
 312:libcanard/drivers/stm32/canard_stm32.h ****     return 0;
ARM GAS  /tmp/ccxbGVnb.s 			page 12


 237              		.loc 2 312 0
 238 00c6 0023     		movs	r3, #0
 239              	.LVL32:
 240              	.L11:
 241              	.LBE6:
 242              	.LBE5:
  77:Src/uavcan.c  ****     if (result)
 243              		.loc 1 77 0
 244 00c8 03B1     		cbz	r3, .L20
  78:Src/uavcan.c  ****     {
  79:Src/uavcan.c  ****         __ASM volatile("BKPT #01");
 245              		.loc 1 79 0
 246              		.syntax unified
 247              	@ 79 "Src/uavcan.c" 1
 248 00ca 01BE     		BKPT #01
 249              	@ 0 "" 2
 250              		.thumb
 251              		.syntax unified
 252              	.L20:
  80:Src/uavcan.c  ****     }
  81:Src/uavcan.c  ****     result = canardSTM32Init(&timings, CanardSTM32IfaceModeNormal);
 253              		.loc 1 81 0
 254 00cc 0021     		movs	r1, #0
 255 00ce 02A8     		add	r0, sp, #8
 256 00d0 FFF7FEFF 		bl	canardSTM32Init
 257              	.LVL33:
  82:Src/uavcan.c  ****     if (result)
 258              		.loc 1 82 0
 259 00d4 00B1     		cbz	r0, .L21
  83:Src/uavcan.c  ****     {
  84:Src/uavcan.c  ****         __ASM volatile("BKPT #01");
 260              		.loc 1 84 0
 261              		.syntax unified
 262              	@ 84 "Src/uavcan.c" 1
 263 00d6 01BE     		BKPT #01
 264              	@ 0 "" 2
 265              		.thumb
 266              		.syntax unified
 267              	.L21:
  85:Src/uavcan.c  ****     }
  86:Src/uavcan.c  ****  
  87:Src/uavcan.c  ****     canardInit(&g_canard,                         // Uninitialized library instance
 268              		.loc 1 87 0
 269 00d8 154C     		ldr	r4, .L32+20
 270 00da 0023     		movs	r3, #0
 271 00dc 0193     		str	r3, [sp, #4]
 272 00de 154B     		ldr	r3, .L32+24
 273 00e0 0093     		str	r3, [sp]
 274 00e2 154B     		ldr	r3, .L32+28
 275 00e4 4FF48062 		mov	r2, #1024
 276 00e8 1449     		ldr	r1, .L32+32
 277 00ea 2046     		mov	r0, r4
 278              	.LVL34:
 279 00ec FFF7FEFF 		bl	canardInit
 280              	.LVL35:
  88:Src/uavcan.c  ****                g_canard_memory_pool,              // Raw memory chunk used for dynamic allocation
  89:Src/uavcan.c  ****                sizeof(g_canard_memory_pool),      // Size of the above, in bytes
ARM GAS  /tmp/ccxbGVnb.s 			page 13


  90:Src/uavcan.c  ****                onTransferReceived,                // Callback, see CanardOnTransferReception
  91:Src/uavcan.c  ****                shouldAcceptTransfer,              // Callback, see CanardShouldAcceptTransfer
  92:Src/uavcan.c  ****                NULL);
  93:Src/uavcan.c  ****  
  94:Src/uavcan.c  ****     canardSetLocalNodeID(&g_canard, 10);
 281              		.loc 1 94 0
 282 00f0 0A21     		movs	r1, #10
 283 00f2 2046     		mov	r0, r4
 284 00f4 FFF7FEFF 		bl	canardSetLocalNodeID
 285              	.LVL36:
  95:Src/uavcan.c  **** }
 286              		.loc 1 95 0
 287 00f8 05B0     		add	sp, sp, #20
 288              	.LCFI2:
 289              		.cfi_remember_state
 290              		.cfi_def_cfa_offset 20
 291              		@ sp needed
 292 00fa F0BD     		pop	{r4, r5, r6, r7, pc}
 293              	.LVL37:
 294              	.L25:
 295              	.LCFI3:
 296              		.cfi_restore_state
 297              	.LBB10:
 298              	.LBB9:
 289:libcanard/drivers/stm32/canard_stm32.h **** 
 299              		.loc 2 289 0
 300 00fc 0022     		movs	r2, #0
 301              	.LVL38:
 302 00fe D0E7     		b	.L17
 303              	.LVL39:
 304              	.L26:
 305 0100 0122     		movs	r2, #1
 306              	.LVL40:
 307 0102 CEE7     		b	.L17
 308              	.LVL41:
 309              	.L18:
 303:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;
 310              		.loc 2 303 0
 311 0104 0E4B     		ldr	r3, .L32+36
 312 0106 074A     		ldr	r2, .L32+8
 313              	.LVL42:
 314 0108 40F22F11 		movw	r1, #303
 315              	.LVL43:
 316 010c 0648     		ldr	r0, .L32+12
 317 010e FFF7FEFF 		bl	__assert_func
 318              	.LVL44:
 319              	.L22:
 245:libcanard/drivers/stm32/canard_stm32.h ****         }
 320              		.loc 2 245 0
 321 0112 0C4B     		ldr	r3, .L32+40
 322              	.LVL45:
 323 0114 D8E7     		b	.L11
 324              	.LVL46:
 325              	.L23:
 253:libcanard/drivers/stm32/canard_stm32.h ****     }
 326              		.loc 2 253 0
 327 0116 0B4B     		ldr	r3, .L32+40
ARM GAS  /tmp/ccxbGVnb.s 			page 14


 328              	.LVL47:
 329 0118 D6E7     		b	.L11
 330              	.L33:
 331 011a 00BF     		.align	2
 332              	.L32:
 333 011c 83DE1B43 		.word	1125899907
 334 0120 00000000 		.word	.LC0
 335 0124 00000000 		.word	.LANCHOR0
 336 0128 14000000 		.word	.LC1
 337 012c 40420F00 		.word	1000000
 338 0130 00000000 		.word	.LANCHOR2
 339 0134 00000000 		.word	shouldAcceptTransfer
 340 0138 00000000 		.word	onTransferReceived
 341 013c 00000000 		.word	.LANCHOR1
 342 0140 3C000000 		.word	.LC2
 343 0144 18FCFFFF 		.word	-1000
 344              	.LBE9:
 345              	.LBE10:
 346              		.cfi_endproc
 347              	.LFE68:
 349              		.section	.text.sendCanard,"ax",%progbits
 350              		.align	1
 351              		.global	sendCanard
 352              		.syntax unified
 353              		.thumb
 354              		.thumb_func
 355              		.fpu softvfp
 357              	sendCanard:
 358              	.LFB69:
  96:Src/uavcan.c  **** 
  97:Src/uavcan.c  **** void sendCanard(void)
  98:Src/uavcan.c  **** {
 359              		.loc 1 98 0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 0
 362              		@ frame_needed = 0, uses_anonymous_args = 0
 363 0000 08B5     		push	{r3, lr}
 364              	.LCFI4:
 365              		.cfi_def_cfa_offset 8
 366              		.cfi_offset 3, -8
 367              		.cfi_offset 14, -4
  99:Src/uavcan.c  ****   const CanardCANFrame* txf = canardPeekTxQueue(&g_canard); 
 368              		.loc 1 99 0
 369 0002 0A48     		ldr	r0, .L42
 370 0004 FFF7FEFF 		bl	canardPeekTxQueue
 371              	.LVL48:
 100:Src/uavcan.c  ****   while(txf)
 372              		.loc 1 100 0
 373 0008 04E0     		b	.L35
 374              	.LVL49:
 375              	.L41:
 376              	.LBB11:
 101:Src/uavcan.c  ****     {
 102:Src/uavcan.c  ****         const int tx_res = canardSTM32Transmit(txf);
 103:Src/uavcan.c  ****         if (tx_res < 0)                  // Failure - drop the frame and report
 104:Src/uavcan.c  ****         {
 105:Src/uavcan.c  ****             __ASM volatile("BKPT #01");  // TODO: handle the error properly
ARM GAS  /tmp/ccxbGVnb.s 			page 15


 377              		.loc 1 105 0
 378              		.syntax unified
 379              	@ 105 "Src/uavcan.c" 1
 380 000a 01BE     		BKPT #01
 381              	@ 0 "" 2
 382              		.thumb
 383              		.syntax unified
 384 000c 07E0     		b	.L36
 385              	.LVL50:
 386              	.L37:
 106:Src/uavcan.c  ****         }
 107:Src/uavcan.c  ****         if(tx_res > 0)
 108:Src/uavcan.c  ****         {
 109:Src/uavcan.c  ****             canardPopTxQueue(&g_canard);
 110:Src/uavcan.c  ****         }
 111:Src/uavcan.c  ****         txf = canardPeekTxQueue(&g_canard); 
 387              		.loc 1 111 0
 388 000e 0748     		ldr	r0, .L42
 389 0010 FFF7FEFF 		bl	canardPeekTxQueue
 390              	.LVL51:
 391              	.L35:
 392              	.LBE11:
 100:Src/uavcan.c  ****     {
 393              		.loc 1 100 0
 394 0014 48B1     		cbz	r0, .L40
 395              	.LBB12:
 102:Src/uavcan.c  ****         if (tx_res < 0)                  // Failure - drop the frame and report
 396              		.loc 1 102 0
 397 0016 FFF7FEFF 		bl	canardSTM32Transmit
 398              	.LVL52:
 103:Src/uavcan.c  ****         {
 399              		.loc 1 103 0
 400 001a 0028     		cmp	r0, #0
 401 001c F5DB     		blt	.L41
 402              	.L36:
 107:Src/uavcan.c  ****         {
 403              		.loc 1 107 0
 404 001e 0028     		cmp	r0, #0
 405 0020 F5DD     		ble	.L37
 109:Src/uavcan.c  ****         }
 406              		.loc 1 109 0
 407 0022 0248     		ldr	r0, .L42
 408              	.LVL53:
 409 0024 FFF7FEFF 		bl	canardPopTxQueue
 410              	.LVL54:
 411 0028 F1E7     		b	.L37
 412              	.LVL55:
 413              	.L40:
 414              	.LBE12:
 112:Src/uavcan.c  ****     }
 113:Src/uavcan.c  **** }
 415              		.loc 1 113 0
 416 002a 08BD     		pop	{r3, pc}
 417              	.L43:
 418              		.align	2
 419              	.L42:
 420 002c 00000000 		.word	.LANCHOR2
ARM GAS  /tmp/ccxbGVnb.s 			page 16


 421              		.cfi_endproc
 422              	.LFE69:
 424              		.section	.text.receiveCanard,"ax",%progbits
 425              		.align	1
 426              		.global	receiveCanard
 427              		.syntax unified
 428              		.thumb
 429              		.thumb_func
 430              		.fpu softvfp
 432              	receiveCanard:
 433              	.LFB70:
 114:Src/uavcan.c  **** 
 115:Src/uavcan.c  **** void receiveCanard(void)
 116:Src/uavcan.c  **** {
 434              		.loc 1 116 0
 435              		.cfi_startproc
 436              		@ args = 0, pretend = 0, frame = 16
 437              		@ frame_needed = 0, uses_anonymous_args = 0
 438 0000 00B5     		push	{lr}
 439              	.LCFI5:
 440              		.cfi_def_cfa_offset 4
 441              		.cfi_offset 14, -4
 442 0002 85B0     		sub	sp, sp, #20
 443              	.LCFI6:
 444              		.cfi_def_cfa_offset 24
 117:Src/uavcan.c  ****     CanardCANFrame rx_frame;
 118:Src/uavcan.c  ****     int res = canardSTM32Receive(&rx_frame);
 445              		.loc 1 118 0
 446 0004 6846     		mov	r0, sp
 447 0006 FFF7FEFF 		bl	canardSTM32Receive
 448              	.LVL56:
 119:Src/uavcan.c  ****     if(res)
 449              		.loc 1 119 0
 450 000a 10B9     		cbnz	r0, .L47
 451              	.LVL57:
 452              	.L44:
 120:Src/uavcan.c  ****     {
 121:Src/uavcan.c  ****         canardHandleRxFrame(&g_canard, &rx_frame, HAL_GetTick() * 1000);
 122:Src/uavcan.c  ****     }    
 123:Src/uavcan.c  **** }
 453              		.loc 1 123 0
 454 000c 05B0     		add	sp, sp, #20
 455              	.LCFI7:
 456              		.cfi_remember_state
 457              		.cfi_def_cfa_offset 4
 458              		@ sp needed
 459 000e 5DF804FB 		ldr	pc, [sp], #4
 460              	.LVL58:
 461              	.L47:
 462              	.LCFI8:
 463              		.cfi_restore_state
 121:Src/uavcan.c  ****     }    
 464              		.loc 1 121 0
 465 0012 FFF7FEFF 		bl	HAL_GetTick
 466              	.LVL59:
 467 0016 4FF47A72 		mov	r2, #1000
 468 001a 02FB00F2 		mul	r2, r2, r0
ARM GAS  /tmp/ccxbGVnb.s 			page 17


 469 001e 0023     		movs	r3, #0
 470 0020 6946     		mov	r1, sp
 471 0022 0248     		ldr	r0, .L48
 472 0024 FFF7FEFF 		bl	canardHandleRxFrame
 473              	.LVL60:
 474              		.loc 1 123 0
 475 0028 F0E7     		b	.L44
 476              	.L49:
 477 002a 00BF     		.align	2
 478              	.L48:
 479 002c 00000000 		.word	.LANCHOR2
 480              		.cfi_endproc
 481              	.LFE70:
 483              		.section	.text.makeNodeStatusMessage,"ax",%progbits
 484              		.align	1
 485              		.global	makeNodeStatusMessage
 486              		.syntax unified
 487              		.thumb
 488              		.thumb_func
 489              		.fpu softvfp
 491              	makeNodeStatusMessage:
 492              	.LFB72:
 124:Src/uavcan.c  **** void spinCanard(void)
 125:Src/uavcan.c  **** {  
 126:Src/uavcan.c  ****     static uint32_t spin_time = 0;
 127:Src/uavcan.c  ****     if(HAL_GetTick() < spin_time + CANARD_SPIN_PERIOD) return;  // rate limiting
 128:Src/uavcan.c  ****     spin_time = HAL_GetTick();
 129:Src/uavcan.c  ****     HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_12);   
 130:Src/uavcan.c  ****     
 131:Src/uavcan.c  ****     uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE];    
 132:Src/uavcan.c  ****     static uint8_t transfer_id = 0;                           // This variable MUST BE STATIC; refe
 133:Src/uavcan.c  ****     makeNodeStatusMessage(buffer);  
 134:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 135:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE,
 136:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_DATA_TYPE_ID,
 137:Src/uavcan.c  ****                     &transfer_id,
 138:Src/uavcan.c  ****                     CANARD_TRANSFER_PRIORITY_LOW,
 139:Src/uavcan.c  ****                     buffer, 
 140:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_MESSAGE_SIZE);                         //some indication
 141:Src/uavcan.c  ****     
 142:Src/uavcan.c  **** }
 143:Src/uavcan.c  **** 
 144:Src/uavcan.c  **** void makeNodeStatusMessage(uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE])
 145:Src/uavcan.c  **** {
 493              		.loc 1 145 0
 494              		.cfi_startproc
 495              		@ args = 0, pretend = 0, frame = 8
 496              		@ frame_needed = 0, uses_anonymous_args = 0
 497              	.LVL61:
 498 0000 30B5     		push	{r4, r5, lr}
 499              	.LCFI9:
 500              		.cfi_def_cfa_offset 12
 501              		.cfi_offset 4, -12
 502              		.cfi_offset 5, -8
 503              		.cfi_offset 14, -4
 504 0002 83B0     		sub	sp, sp, #12
 505              	.LCFI10:
ARM GAS  /tmp/ccxbGVnb.s 			page 18


 506              		.cfi_def_cfa_offset 24
 507 0004 0446     		mov	r4, r0
 146:Src/uavcan.c  ****     uint8_t node_health = UAVCAN_NODE_HEALTH_OK;
 508              		.loc 1 146 0
 509 0006 0025     		movs	r5, #0
 510 0008 8DF80750 		strb	r5, [sp, #7]
 147:Src/uavcan.c  ****     uint8_t node_mode   = UAVCAN_NODE_MODE_OPERATIONAL;
 511              		.loc 1 147 0
 512 000c 8DF80650 		strb	r5, [sp, #6]
 148:Src/uavcan.c  ****     memset(buffer, 0, UAVCAN_NODE_STATUS_MESSAGE_SIZE);
 513              		.loc 1 148 0
 514 0010 0560     		str	r5, [r0]	@ unaligned
 515 0012 C0F80350 		str	r5, [r0, #3]	@ unaligned
 149:Src/uavcan.c  ****     uint32_t uptime_sec = (HAL_GetTick() / 1000);
 516              		.loc 1 149 0
 517 0016 FFF7FEFF 		bl	HAL_GetTick
 518              	.LVL62:
 519 001a 0E4B     		ldr	r3, .L52
 520 001c A3FB0030 		umull	r3, r0, r3, r0
 521 0020 8009     		lsrs	r0, r0, #6
 522 0022 02AB     		add	r3, sp, #8
 523 0024 43F8080D 		str	r0, [r3, #-8]!
 150:Src/uavcan.c  ****     canardEncodeScalar(buffer,  0, 32, &uptime_sec);
 524              		.loc 1 150 0
 525 0028 2022     		movs	r2, #32
 526 002a 2946     		mov	r1, r5
 527 002c 2046     		mov	r0, r4
 528 002e FFF7FEFF 		bl	canardEncodeScalar
 529              	.LVL63:
 151:Src/uavcan.c  ****     canardEncodeScalar(buffer, 32,  2, &node_health);
 530              		.loc 1 151 0
 531 0032 0DF10703 		add	r3, sp, #7
 532 0036 0222     		movs	r2, #2
 533 0038 2021     		movs	r1, #32
 534 003a 2046     		mov	r0, r4
 535 003c FFF7FEFF 		bl	canardEncodeScalar
 536              	.LVL64:
 152:Src/uavcan.c  ****     canardEncodeScalar(buffer, 34,  3, &node_mode);
 537              		.loc 1 152 0
 538 0040 0DF10603 		add	r3, sp, #6
 539 0044 0322     		movs	r2, #3
 540 0046 2221     		movs	r1, #34
 541 0048 2046     		mov	r0, r4
 542 004a FFF7FEFF 		bl	canardEncodeScalar
 543              	.LVL65:
 153:Src/uavcan.c  **** }
 544              		.loc 1 153 0
 545 004e 03B0     		add	sp, sp, #12
 546              	.LCFI11:
 547              		.cfi_def_cfa_offset 12
 548              		@ sp needed
 549 0050 30BD     		pop	{r4, r5, pc}
 550              	.LVL66:
 551              	.L53:
 552 0052 00BF     		.align	2
 553              	.L52:
 554 0054 D34D6210 		.word	274877907
ARM GAS  /tmp/ccxbGVnb.s 			page 19


 555              		.cfi_endproc
 556              	.LFE72:
 558              		.section	.text.spinCanard,"ax",%progbits
 559              		.align	1
 560              		.global	spinCanard
 561              		.syntax unified
 562              		.thumb
 563              		.thumb_func
 564              		.fpu softvfp
 566              	spinCanard:
 567              	.LFB71:
 125:Src/uavcan.c  ****     static uint32_t spin_time = 0;
 568              		.loc 1 125 0
 569              		.cfi_startproc
 570              		@ args = 0, pretend = 0, frame = 8
 571              		@ frame_needed = 0, uses_anonymous_args = 0
 572 0000 10B5     		push	{r4, lr}
 573              	.LCFI12:
 574              		.cfi_def_cfa_offset 8
 575              		.cfi_offset 4, -8
 576              		.cfi_offset 14, -4
 577 0002 88B0     		sub	sp, sp, #32
 578              	.LCFI13:
 579              		.cfi_def_cfa_offset 40
 127:Src/uavcan.c  ****     spin_time = HAL_GetTick();
 580              		.loc 1 127 0
 581 0004 FFF7FEFF 		bl	HAL_GetTick
 582              	.LVL67:
 583 0008 154B     		ldr	r3, .L59+8
 584 000a 1B68     		ldr	r3, [r3]
 585 000c 03F5FA73 		add	r3, r3, #500
 586 0010 9842     		cmp	r0, r3
 587 0012 01D2     		bcs	.L58
 588              	.L54:
 142:Src/uavcan.c  **** 
 589              		.loc 1 142 0
 590 0014 08B0     		add	sp, sp, #32
 591              	.LCFI14:
 592              		.cfi_remember_state
 593              		.cfi_def_cfa_offset 8
 594              		@ sp needed
 595 0016 10BD     		pop	{r4, pc}
 596              	.L58:
 597              	.LCFI15:
 598              		.cfi_restore_state
 128:Src/uavcan.c  ****     HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_12);   
 599              		.loc 1 128 0
 600 0018 FFF7FEFF 		bl	HAL_GetTick
 601              	.LVL68:
 602 001c 104B     		ldr	r3, .L59+8
 603 001e 1860     		str	r0, [r3]
 129:Src/uavcan.c  ****     
 604              		.loc 1 129 0
 605 0020 4FF48051 		mov	r1, #4096
 606 0024 0F48     		ldr	r0, .L59+12
 607 0026 FFF7FEFF 		bl	HAL_GPIO_TogglePin
 608              	.LVL69:
ARM GAS  /tmp/ccxbGVnb.s 			page 20


 133:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 609              		.loc 1 133 0
 610 002a 06AC     		add	r4, sp, #24
 611 002c 2046     		mov	r0, r4
 612 002e FFF7FEFF 		bl	makeNodeStatusMessage
 613              	.LVL70:
 134:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE,
 614              		.loc 1 134 0
 615 0032 0723     		movs	r3, #7
 616 0034 0493     		str	r3, [sp, #16]
 617 0036 0394     		str	r4, [sp, #12]
 618 0038 1823     		movs	r3, #24
 619 003a 0293     		str	r3, [sp, #8]
 620 003c 0A4B     		ldr	r3, .L59+16
 621 003e 0193     		str	r3, [sp, #4]
 622 0040 40F25513 		movw	r3, #341
 623 0044 0093     		str	r3, [sp]
 624 0046 04A3     		adr	r3, .L59
 625 0048 D3E90023 		ldrd	r2, [r3]
 626 004c 0748     		ldr	r0, .L59+20
 627 004e FFF7FEFF 		bl	canardBroadcast
 628              	.LVL71:
 629 0052 DFE7     		b	.L54
 630              	.L60:
 631 0054 AFF30080 		.align	3
 632              	.L59:
 633 0058 F1C6A7C1 		.word	-1045969167
 634 005c D068080F 		.word	252209360
 635 0060 00000000 		.word	.LANCHOR3
 636 0064 000C0140 		.word	1073810432
 637 0068 00000000 		.word	.LANCHOR4
 638 006c 00000000 		.word	.LANCHOR2
 639              		.cfi_endproc
 640              	.LFE71:
 642              		.section	.text.readUniqueID,"ax",%progbits
 643              		.align	1
 644              		.global	readUniqueID
 645              		.syntax unified
 646              		.thumb
 647              		.thumb_func
 648              		.fpu softvfp
 650              	readUniqueID:
 651              	.LFB74:
 154:Src/uavcan.c  **** 
 155:Src/uavcan.c  **** uint16_t makeNodeInfoMessage(uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE])
 156:Src/uavcan.c  **** {
 157:Src/uavcan.c  ****     memset(buffer, 0, UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
 158:Src/uavcan.c  ****     makeNodeStatusMessage(buffer);
 159:Src/uavcan.c  ****    
 160:Src/uavcan.c  ****     buffer[7] = APP_VERSION_MAJOR;
 161:Src/uavcan.c  ****     buffer[8] = APP_VERSION_MINOR;
 162:Src/uavcan.c  ****     buffer[9] = 1;                          // Optional field flags, VCS commit is set
 163:Src/uavcan.c  ****     uint32_t u32 = GIT_HASH;
 164:Src/uavcan.c  ****     canardEncodeScalar(buffer, 80, 32, &u32); 
 165:Src/uavcan.c  ****     
 166:Src/uavcan.c  ****     readUniqueID(&buffer[24]);
 167:Src/uavcan.c  ****     const size_t name_len = strlen(APP_NODE_NAME);
ARM GAS  /tmp/ccxbGVnb.s 			page 21


 168:Src/uavcan.c  ****     memcpy(&buffer[41], APP_NODE_NAME, name_len);
 169:Src/uavcan.c  ****     return 41 + name_len ;
 170:Src/uavcan.c  **** }
 171:Src/uavcan.c  **** 
 172:Src/uavcan.c  **** void readUniqueID(uint8_t* out_uid)
 173:Src/uavcan.c  **** {
 652              		.loc 1 173 0
 653              		.cfi_startproc
 654              		@ args = 0, pretend = 0, frame = 0
 655              		@ frame_needed = 0, uses_anonymous_args = 0
 656              		@ link register save eliminated.
 657              	.LVL72:
 658              	.LBB13:
 174:Src/uavcan.c  ****     for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
 659              		.loc 1 174 0
 660 0000 0023     		movs	r3, #0
 661 0002 02E0     		b	.L62
 662              	.LVL73:
 663              	.L63:
 175:Src/uavcan.c  ****     {
 176:Src/uavcan.c  ****         out_uid[i] = i;
 664              		.loc 1 176 0 discriminator 3
 665 0004 C354     		strb	r3, [r0, r3]
 174:Src/uavcan.c  ****     for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
 666              		.loc 1 174 0 discriminator 3
 667 0006 0133     		adds	r3, r3, #1
 668              	.LVL74:
 669 0008 DBB2     		uxtb	r3, r3
 670              	.LVL75:
 671              	.L62:
 174:Src/uavcan.c  ****     for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
 672              		.loc 1 174 0 is_stmt 0 discriminator 1
 673 000a 0F2B     		cmp	r3, #15
 674 000c FAD9     		bls	.L63
 675              	.LBE13:
 177:Src/uavcan.c  ****     }
 178:Src/uavcan.c  **** }...
 676              		.loc 1 178 0 is_stmt 1
 677 000e 7047     		bx	lr
 678              		.cfi_endproc
 679              	.LFE74:
 681              		.section	.text.makeNodeInfoMessage,"ax",%progbits
 682              		.align	1
 683              		.global	makeNodeInfoMessage
 684              		.syntax unified
 685              		.thumb
 686              		.thumb_func
 687              		.fpu softvfp
 689              	makeNodeInfoMessage:
 690              	.LFB73:
 156:Src/uavcan.c  **** {
 691              		.loc 1 156 0
 692              		.cfi_startproc
 693              		@ args = 0, pretend = 0, frame = 8
 694              		@ frame_needed = 0, uses_anonymous_args = 0
 695              	.LVL76:
 696 0000 30B5     		push	{r4, r5, lr}
ARM GAS  /tmp/ccxbGVnb.s 			page 22


 697              	.LCFI16:
 698              		.cfi_def_cfa_offset 12
 699              		.cfi_offset 4, -12
 700              		.cfi_offset 5, -8
 701              		.cfi_offset 14, -4
 702 0002 83B0     		sub	sp, sp, #12
 703              	.LCFI17:
 704              		.cfi_def_cfa_offset 24
 705 0004 0446     		mov	r4, r0
 157:Src/uavcan.c  ****     memset(buffer, 0, UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
 706              		.loc 1 157 0
 707 0006 40F27912 		movw	r2, #377
 708 000a 0021     		movs	r1, #0
 709 000c FFF7FEFF 		bl	memset
 710              	.LVL77:
 158:Src/uavcan.c  ****     makeNodeStatusMessage(buffer);
 711              		.loc 1 158 0
 712 0010 2046     		mov	r0, r4
 713 0012 FFF7FEFF 		bl	makeNodeStatusMessage
 714              	.LVL78:
 160:Src/uavcan.c  ****     buffer[7] = APP_VERSION_MAJOR;
 715              		.loc 1 160 0
 716 0016 6323     		movs	r3, #99
 717 0018 E371     		strb	r3, [r4, #7]
 161:Src/uavcan.c  ****     buffer[8] = APP_VERSION_MINOR;
 718              		.loc 1 161 0
 719 001a 2372     		strb	r3, [r4, #8]
 162:Src/uavcan.c  ****     buffer[9] = 1;                          // Optional field flags, VCS commit is set
 720              		.loc 1 162 0
 721 001c 0123     		movs	r3, #1
 722 001e 6372     		strb	r3, [r4, #9]
 163:Src/uavcan.c  ****     uint32_t u32 = GIT_HASH;
 723              		.loc 1 163 0
 724 0020 02AB     		add	r3, sp, #8
 725 0022 0E4A     		ldr	r2, .L66
 726 0024 43F8042D 		str	r2, [r3, #-4]!
 164:Src/uavcan.c  ****     canardEncodeScalar(buffer, 80, 32, &u32); 
 727              		.loc 1 164 0
 728 0028 2022     		movs	r2, #32
 729 002a 5021     		movs	r1, #80
 730 002c 2046     		mov	r0, r4
 731 002e FFF7FEFF 		bl	canardEncodeScalar
 732              	.LVL79:
 166:Src/uavcan.c  ****     readUniqueID(&buffer[24]);
 733              		.loc 1 166 0
 734 0032 04F11800 		add	r0, r4, #24
 735 0036 FFF7FEFF 		bl	readUniqueID
 736              	.LVL80:
 168:Src/uavcan.c  ****     memcpy(&buffer[41], APP_NODE_NAME, name_len);
 737              		.loc 1 168 0
 738 003a 094B     		ldr	r3, .L66+4
 739 003c 07CB     		ldmia	r3!, {r0, r1, r2}
 740 003e C4F82900 		str	r0, [r4, #41]	@ unaligned
 741 0042 C4F82D10 		str	r1, [r4, #45]	@ unaligned
 742 0046 C4F83120 		str	r2, [r4, #49]	@ unaligned
 743 004a 1A88     		ldrh	r2, [r3]	@ unaligned
 744 004c 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
ARM GAS  /tmp/ccxbGVnb.s 			page 23


 745 004e A4F83520 		strh	r2, [r4, #53]	@ unaligned
 746 0052 84F83730 		strb	r3, [r4, #55]
 170:Src/uavcan.c  **** }
 747              		.loc 1 170 0
 748 0056 3820     		movs	r0, #56
 749 0058 03B0     		add	sp, sp, #12
 750              	.LCFI18:
 751              		.cfi_def_cfa_offset 12
 752              		@ sp needed
 753 005a 30BD     		pop	{r4, r5, pc}
 754              	.LVL81:
 755              	.L67:
 756              		.align	2
 757              	.L66:
 758 005c FE0FDCBA 		.word	-1159983106
 759 0060 00000000 		.word	.LC3
 760              		.cfi_endproc
 761              	.LFE73:
 763              		.section	.text.getNodeInfoHandleCanard,"ax",%progbits
 764              		.align	1
 765              		.global	getNodeInfoHandleCanard
 766              		.syntax unified
 767              		.thumb
 768              		.thumb_func
 769              		.fpu softvfp
 771              	getNodeInfoHandleCanard:
 772              	.LFB67:
  54:Src/uavcan.c  **** {
 773              		.loc 1 54 0
 774              		.cfi_startproc
 775              		@ args = 0, pretend = 0, frame = 384
 776              		@ frame_needed = 0, uses_anonymous_args = 0
 777              	.LVL82:
 778 0000 30B5     		push	{r4, r5, lr}
 779              	.LCFI19:
 780              		.cfi_def_cfa_offset 12
 781              		.cfi_offset 4, -12
 782              		.cfi_offset 5, -8
 783              		.cfi_offset 14, -4
 784 0002 E7B0     		sub	sp, sp, #412
 785              	.LCFI20:
 786              		.cfi_def_cfa_offset 424
 787 0004 0446     		mov	r4, r0
  56:Src/uavcan.c  ****         memset(buffer,0,UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
 788              		.loc 1 56 0
 789 0006 07AD     		add	r5, sp, #28
 790 0008 40F27912 		movw	r2, #377
 791 000c 0021     		movs	r1, #0
 792 000e 2846     		mov	r0, r5
 793              	.LVL83:
 794 0010 FFF7FEFF 		bl	memset
 795              	.LVL84:
  57:Src/uavcan.c  ****         uint16_t len = makeNodeInfoMessage(buffer);
 796              		.loc 1 57 0
 797 0014 2846     		mov	r0, r5
 798 0016 FFF7FEFF 		bl	makeNodeInfoMessage
 799              	.LVL85:
ARM GAS  /tmp/ccxbGVnb.s 			page 24


  58:Src/uavcan.c  ****         int result = canardRequestOrRespond(&g_canard,
 800              		.loc 1 58 0
 801 001a E17E     		ldrb	r1, [r4, #27]	@ zero_extendqisi2
 802 001c 0590     		str	r0, [sp, #20]
 803 001e 0495     		str	r5, [sp, #16]
 804 0020 0023     		movs	r3, #0
 805 0022 0393     		str	r3, [sp, #12]
 806 0024 A37E     		ldrb	r3, [r4, #26]	@ zero_extendqisi2
 807 0026 0293     		str	r3, [sp, #8]
 808 0028 1934     		adds	r4, r4, #25
 809              	.LVL86:
 810 002a 0194     		str	r4, [sp, #4]
 811 002c 0123     		movs	r3, #1
 812 002e 0093     		str	r3, [sp]
 813 0030 04A3     		adr	r3, .L70+4
 814 0032 D3E90023 		ldrd	r2, [r3]
 815 0036 0248     		ldr	r0, .L70
 816              	.LVL87:
 817 0038 FFF7FEFF 		bl	canardRequestOrRespond
 818              	.LVL88:
  67:Src/uavcan.c  **** }
 819              		.loc 1 67 0
 820 003c 67B0     		add	sp, sp, #412
 821              	.LCFI21:
 822              		.cfi_def_cfa_offset 12
 823              		@ sp needed
 824 003e 30BD     		pop	{r4, r5, pc}
 825              	.LVL89:
 826              	.L71:
 827              		.align	3
 828              	.L70:
 829 0040 00000000 		.word	.LANCHOR2
 830 0044 9E6AC421 		.word	566520478
 831 0048 818A46EE 		.word	-297366911
 832              		.cfi_endproc
 833              	.LFE67:
 835              		.section	.text.onTransferReceived,"ax",%progbits
 836              		.align	1
 837              		.global	onTransferReceived
 838              		.syntax unified
 839              		.thumb
 840              		.thumb_func
 841              		.fpu softvfp
 843              	onTransferReceived:
 844              	.LFB66:
  44:Src/uavcan.c  **** {
 845              		.loc 1 44 0
 846              		.cfi_startproc
 847              		@ args = 0, pretend = 0, frame = 0
 848              		@ frame_needed = 0, uses_anonymous_args = 0
 849              	.LVL90:
 850 0000 08B5     		push	{r3, lr}
 851              	.LCFI22:
 852              		.cfi_def_cfa_offset 8
 853              		.cfi_offset 3, -8
 854              		.cfi_offset 14, -4
  45:Src/uavcan.c  ****     if ((transfer->transfer_type == CanardTransferTypeRequest) &&
ARM GAS  /tmp/ccxbGVnb.s 			page 25


 855              		.loc 1 45 0
 856 0002 0B7E     		ldrb	r3, [r1, #24]	@ zero_extendqisi2
 857 0004 012B     		cmp	r3, #1
 858 0006 00D0     		beq	.L75
 859              	.LVL91:
 860              	.L72:
 861 0008 08BD     		pop	{r3, pc}
 862              	.LVL92:
 863              	.L75:
  46:Src/uavcan.c  ****         (transfer->data_type_id == UAVCAN_GET_NODE_INFO_DATA_TYPE_ID))
 864              		.loc 1 46 0 discriminator 1
 865 000a CB8A     		ldrh	r3, [r1, #22]
  45:Src/uavcan.c  ****     if ((transfer->transfer_type == CanardTransferTypeRequest) &&
 866              		.loc 1 45 0 discriminator 1
 867 000c 012B     		cmp	r3, #1
 868 000e FBD1     		bne	.L72
 869 0010 0846     		mov	r0, r1
 870              	.LVL93:
  48:Src/uavcan.c  ****         getNodeInfoHandleCanard(transfer);
 871              		.loc 1 48 0
 872 0012 FFF7FEFF 		bl	getNodeInfoHandleCanard
 873              	.LVL94:
  51:Src/uavcan.c  **** }
 874              		.loc 1 51 0
 875 0016 F7E7     		b	.L72
 876              		.cfi_endproc
 877              	.LFE66:
 879              		.section	.bss.g_canard,"aw",%nobits
 880              		.align	2
 881              		.set	.LANCHOR2,. + 0
 884              	g_canard:
 885 0000 00000000 		.space	36
 885      00000000 
 885      00000000 
 885      00000000 
 885      00000000 
 886              		.section	.bss.g_canard_memory_pool,"aw",%nobits
 887              		.align	2
 888              		.set	.LANCHOR1,. + 0
 891              	g_canard_memory_pool:
 892 0000 00000000 		.space	1024
 892      00000000 
 892      00000000 
 892      00000000 
 892      00000000 
 893              		.section	.bss.spin_time.7001,"aw",%nobits
 894              		.align	2
 895              		.set	.LANCHOR3,. + 0
 898              	spin_time.7001:
 899 0000 00000000 		.space	4
 900              		.section	.bss.transfer_id.7003,"aw",%nobits
 901              		.set	.LANCHOR4,. + 0
 904              	transfer_id.7003:
 905 0000 00       		.space	1
 906              		.section	.rodata.__func__.4729,"a",%progbits
 907              		.align	2
 908              		.set	.LANCHOR0,. + 0
ARM GAS  /tmp/ccxbGVnb.s 			page 26


 911              	__func__.4729:
 912 0000 63616E61 		.ascii	"canardSTM32ComputeCANTimings\000"
 912      72645354 
 912      4D333243 
 912      6F6D7075 
 912      74654341 
 913              		.section	.rodata.makeNodeInfoMessage.str1.4,"aMS",%progbits,1
 914              		.align	2
 915              	.LC3:
 916 0000 736B7979 		.ascii	"skyyu.node.demo\000"
 916      752E6E6F 
 916      64652E64 
 916      656D6F00 
 917              		.section	.rodata.uavcanInit.str1.4,"aMS",%progbits,1
 918              		.align	2
 919              	.LC0:
 920 0000 6273315F 		.ascii	"bs1_bs2_sum > bs1\000"
 920      6273325F 
 920      73756D20 
 920      3E206273 
 920      3100
 921 0012 0000     		.space	2
 922              	.LC1:
 923 0014 6C696263 		.ascii	"libcanard/drivers/stm32/canard_stm32.h\000"
 923      616E6172 
 923      642F6472 
 923      69766572 
 923      732F7374 
 924 003b 00       		.space	1
 925              	.LC2:
 926 003c 3000     		.ascii	"0\000"
 927              		.text
 928              	.Letext0:
 929              		.file 3 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_types.
 930              		.file 4 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 931              		.file 5 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 932              		.file 6 "libcanard/canard.h"
 933              		.file 7 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 934              		.file 8 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 935              		.file 9 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 936              		.file 10 "Drivers/CMSIS/Include/core_cm3.h"
 937              		.file 11 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 938              		.file 12 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 939              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 940              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 941              		.file 15 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/assert.h"
 942              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_rcc.h"
ARM GAS  /tmp/ccxbGVnb.s 			page 27


DEFINED SYMBOLS
                            *ABS*:0000000000000000 uavcan.c
     /tmp/ccxbGVnb.s:16     .text.shouldAcceptTransfer:0000000000000000 $t
     /tmp/ccxbGVnb.s:23     .text.shouldAcceptTransfer:0000000000000000 shouldAcceptTransfer
     /tmp/ccxbGVnb.s:63     .text.shouldAcceptTransfer:0000000000000020 $d
     /tmp/ccxbGVnb.s:69     .text.uavcanInit:0000000000000000 $t
     /tmp/ccxbGVnb.s:76     .text.uavcanInit:0000000000000000 uavcanInit
     /tmp/ccxbGVnb.s:333    .text.uavcanInit:000000000000011c $d
     /tmp/ccxbGVnb.s:843    .text.onTransferReceived:0000000000000000 onTransferReceived
     /tmp/ccxbGVnb.s:350    .text.sendCanard:0000000000000000 $t
     /tmp/ccxbGVnb.s:357    .text.sendCanard:0000000000000000 sendCanard
     /tmp/ccxbGVnb.s:420    .text.sendCanard:000000000000002c $d
     /tmp/ccxbGVnb.s:425    .text.receiveCanard:0000000000000000 $t
     /tmp/ccxbGVnb.s:432    .text.receiveCanard:0000000000000000 receiveCanard
     /tmp/ccxbGVnb.s:479    .text.receiveCanard:000000000000002c $d
     /tmp/ccxbGVnb.s:484    .text.makeNodeStatusMessage:0000000000000000 $t
     /tmp/ccxbGVnb.s:491    .text.makeNodeStatusMessage:0000000000000000 makeNodeStatusMessage
     /tmp/ccxbGVnb.s:554    .text.makeNodeStatusMessage:0000000000000054 $d
     /tmp/ccxbGVnb.s:559    .text.spinCanard:0000000000000000 $t
     /tmp/ccxbGVnb.s:566    .text.spinCanard:0000000000000000 spinCanard
     /tmp/ccxbGVnb.s:633    .text.spinCanard:0000000000000058 $d
     /tmp/ccxbGVnb.s:643    .text.readUniqueID:0000000000000000 $t
     /tmp/ccxbGVnb.s:650    .text.readUniqueID:0000000000000000 readUniqueID
     /tmp/ccxbGVnb.s:682    .text.makeNodeInfoMessage:0000000000000000 $t
     /tmp/ccxbGVnb.s:689    .text.makeNodeInfoMessage:0000000000000000 makeNodeInfoMessage
     /tmp/ccxbGVnb.s:758    .text.makeNodeInfoMessage:000000000000005c $d
     /tmp/ccxbGVnb.s:764    .text.getNodeInfoHandleCanard:0000000000000000 $t
     /tmp/ccxbGVnb.s:771    .text.getNodeInfoHandleCanard:0000000000000000 getNodeInfoHandleCanard
     /tmp/ccxbGVnb.s:829    .text.getNodeInfoHandleCanard:0000000000000040 $d
     /tmp/ccxbGVnb.s:836    .text.onTransferReceived:0000000000000000 $t
     /tmp/ccxbGVnb.s:880    .bss.g_canard:0000000000000000 $d
     /tmp/ccxbGVnb.s:884    .bss.g_canard:0000000000000000 g_canard
     /tmp/ccxbGVnb.s:887    .bss.g_canard_memory_pool:0000000000000000 $d
     /tmp/ccxbGVnb.s:891    .bss.g_canard_memory_pool:0000000000000000 g_canard_memory_pool
     /tmp/ccxbGVnb.s:894    .bss.spin_time.7001:0000000000000000 $d
     /tmp/ccxbGVnb.s:898    .bss.spin_time.7001:0000000000000000 spin_time.7001
     /tmp/ccxbGVnb.s:904    .bss.transfer_id.7003:0000000000000000 transfer_id.7003
     /tmp/ccxbGVnb.s:905    .bss.transfer_id.7003:0000000000000000 $d
     /tmp/ccxbGVnb.s:907    .rodata.__func__.4729:0000000000000000 $d
     /tmp/ccxbGVnb.s:911    .rodata.__func__.4729:0000000000000000 __func__.4729
     /tmp/ccxbGVnb.s:914    .rodata.makeNodeInfoMessage.str1.4:0000000000000000 $d
     /tmp/ccxbGVnb.s:918    .rodata.uavcanInit.str1.4:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
HAL_RCC_GetPCLK1Freq
__assert_func
canardSTM32Init
canardInit
canardSetLocalNodeID
canardPeekTxQueue
canardSTM32Transmit
canardPopTxQueue
canardSTM32Receive
HAL_GetTick
canardHandleRxFrame
canardEncodeScalar
ARM GAS  /tmp/ccxbGVnb.s 			page 28


HAL_GPIO_TogglePin
canardBroadcast
memset
canardRequestOrRespond
